<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 1. Title updated --><title>pixelmyqube</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<!-- El bloque <style> se ha movido a assets/style.css --><link rel="stylesheet" href="assets/style.css">
</head>
<!-- Fondo del body cambiado a negro --><body class="bg-black font-sans flex flex-col items-center justify-center min-h-screen p-4">

<div class="bg-white shadow-xl rounded-lg p-6 w-full max-w-4xl">
    
    <!-- 4. Text translated to English --><!-- H1 cambiado --><h1 class="text-3xl font-bold text-center text-gray-800 mb-6">PixelmyQube</h1>
    
    <div class="flex flex-col lg:flex-row gap-6">

        <div class="flex-shrink-0 lg:w-1/3">
                <div class="bg-gray-50 p-4 rounded-lg shadow-inner">
                    <h2 class="text-xl font-semibold mb-4 text-gray-700">Controls</h2>

                    <!-- Color Palette --><div class="mb-4">
                        <label class="block text-sm font-medium text-gray-600 mb-2">Color</label>
                        <div id="color-palette" class="flex flex-wrap gap-3 items-center">
                            <div class="color-swatch active" data-color="null" style="background-color: #f0f0f0; background-image: url('data:image/svg+xml;utf8,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%2224%22 height=%2224%22 viewBox=%220 0 24 24%22 fill=%22none%22 stroke=%22currentColor%22 stroke-width=%222%22 stroke-linecap=%22round%22 stroke-linejoin=%22round%22 class=%22feather feather-delete%22><path d=%22M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z%22></path><line x1=%2218%22 y1=%229%22 x2=%2212%22 y2=%2215%22></line><line x1=%2212%22 y1=%229%22 x2=%2218%22 y2=%2215%22></line></svg>'); background-size: 60%; background-position: center; background-repeat: no-repeat;" title="Eraser"></div>
                            <div class="color-swatch" data-color="#E53E3E" style="background-color: #E53E3E" title="Red"></div>
                            <div class="color-swatch" data-color="#38A169" style="background-color: #38A169" title="Green"></div>
                            <div class="color-swatch" data-color="#3182CE" style="background-color: #3182CE" title="Blue"></div>
                            <div class="color-swatch" data-color="#D69E2E" style="background-color: #D69E2E" title="Yellow"></div>
                            <!-- Color changed from Black (#2D3748) to White (#ffffff) -->
                            <div class="color-swatch" data-color="#ffffff" style="background-color: #ffffff" title="White"></div>
                            
                            <input type="color" id="color-picker" class="w-10 h-10 p-0 border-none cursor-pointer rounded-full" value="#FF0000">
                        </div>
                    </div>

                    <!-- Actions --><div class="flex flex-col gap-3 mt-6">
                        <button id="clear-btn" class="w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                            Clear Grid
                        </button>
                        <button id="download-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors" disabled>
                            Loading model...
                        </button>
                    </div>

                    <!-- Statistics --><div id="stats-container" class="mt-6">
                        <h3 class="text-lg font-semibold text-gray-700">Statistics</h3>
                        <div class="bg-white p-3 rounded mt-2">
                            <p id="pixel-count-total" class="text-sm text-gray-600">Total: 0 pixels</p>
                            <div id="pixel-count-colors" class="mt-2 text-sm">
                            </div>
                        </div>
                    </div>

                </div>
            </div>

            <div class="flex-grow flex items-center justify-center">
                <div id="grid-container" class="shadow-lg">
                </div>
            </div>

        </div> 

    </div> 

    <!-- 3. Footer Added --><footer class="text-center text-gray-600 text-sm mt-8 pb-4">
        by <a href="https://okuyuki.cc" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline">Okuyuki</a> for Cooler Master: FreeForm Playground Contest.
    </footer>

    <script type="module">
        // --- 1. CONFIGURATION AND INITIALIZATION ---

        const GRID_SIZE = 17;
        const OBJECT_DIM_MM = 20; // Dimensions of your 3D object (20x20x9.40mm)
        const OBJECT_HEIGHT_MM = 9.40;
        const SPACING_MM = 2; // Spacing between objects
        const TOTAL_CELL_DIM_MM = OBJECT_DIM_MM + SPACING_MM; 
        
        // Scale for the OBJ model.
        // We assume the OBJ is normalized from -1 to 1 (approx)
        // (20mm width / 2 units) = 10
        // (9.40mm height / ~0.94 units) = 10
        const OBJ_SCALE_X = 10.0;
        const OBJ_SCALE_Y = 10.0;
        const OBJ_SCALE_Z = 10.0; 


        const gridContainer = document.getElementById('grid-container');
        const colorPalette = document.getElementById('color-palette');
        const colorPicker = document.getElementById('color-picker');
        const clearBtn = document.getElementById('clear-btn');
        const downloadBtn = document.getElementById('download-btn');
        const statsTotalEl = document.getElementById('pixel-count-total');
        const statsColorsEl = document.getElementById('pixel-count-colors');
        
        let selectedColor = "null"; 
        let isMouseDown = false; 

        let gridData = new Array(GRID_SIZE * GRID_SIZE).fill(null);
        
        // Geometry of the loaded model
        let customGeometry = null;

        /**
         * Creates the pixel grid in the DOM
         */
        function createGrid() {
            gridContainer.innerHTML = ''; 
            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                const pixel = document.createElement('div');
                pixel.classList.add('grid-pixel');
                pixel.dataset.index = i;

                const pixelInner = document.createElement('div');
                pixelInner.classList.add('pixel-inner');
                pixel.appendChild(pixelInner);
                
                // --- Paint Events ---
                pixel.addEventListener('mousedown', (e) => {
                    isMouseDown = true;
                    paintPixel(pixelInner, i);
                });
                
                pixel.addEventListener('mouseover', (e) => {
                    if (isMouseDown) {
                        paintPixel(pixelInner, i);
                    }
                });
                
                gridContainer.appendChild(pixel);
            }
        }
        
        window.addEventListener('mouseup', () => {
            isMouseDown = false;
        });
        gridContainer.addEventListener('mouseleave', () => {
            isMouseDown = false;
        });


        // --- 2. PAINTING AND STATE LOGIC ---

        /**
         * Paints a pixel in the DOM and updates the data
         */
        function paintPixel(pixelInnerElement, index) {
            const newColor = selectedColor === "null" ? null : selectedColor;
            
            if (gridData[index] !== newColor) {
                gridData[index] = newColor;
                pixelInnerElement.style.backgroundColor = newColor || 'transparent';
                if (newColor === null) {
                    pixelInnerElement.classList.remove('painted');
                } else {
                    pixelInnerElement.classList.add('painted');
                }
                updateStats();
            }
        }

        /**
         * Clears the grid and data
         */
        function clearGrid() {
            gridData.fill(null);
            const pixelsInner = gridContainer.querySelectorAll('.pixel-inner');
            pixelsInner.forEach(pixelInner => {
                pixelInner.style.backgroundColor = 'transparent';
                pixelInner.classList.remove('painted');
            });
            updateStats();
        }

        /**
         * Updates statistics (total count and count by color)
         */
        function updateStats() {
            const paintedPixels = gridData.filter(color => color !== null);
            const totalCount = paintedPixels.length;
            
            statsTotalEl.textContent = `Total: ${totalCount} pixels`;
            
            const colorCounts = {};
            paintedPixels.forEach(color => {
                colorCounts[color] = (colorCounts[color] || 0) + 1;
            });
            
            statsColorsEl.innerHTML = ''; 
            const sortedColors = Object.keys(colorCounts).sort((a, b) => colorCounts[b] - colorCounts[a]);
            
            if (sortedColors.length === 0) {
                statsColorsEl.innerHTML = '<p class="text-gray-500">No pixels painted.</p>';
            } else {
                sortedColors.forEach(color => {
                    const count = colorCounts[color];
                    const row = document.createElement('div');
                    row.className = 'flex items-center justify-between';
                    row.innerHTML = `
                        <div class="flex items-center gap-2">
                            <div class="w-3 h-3 rounded-full border border-gray-300" style="background-color: ${color}"></div>
                            <span>${color}</span>
                        </div>
                        <span class="font-medium">${count}</span>
                    `;
                    statsColorsEl.appendChild(row);
                });
            }
        }

        // --- 3. COLOR PALETTE LOGIC ---

        function selectColor(newColor, activeSwatch) {
            selectedColor = newColor;
            
            colorPalette.querySelectorAll('.color-swatch').forEach(swatch => {
                swatch.classList.remove('active');
            });
            
            if (activeSwatch) {
                activeSwatch.classList.add('active');
            }
            
            if (newColor !== 'null' && !activeSwatch) {
                colorPicker.value = newColor;
            }
        }

        colorPalette.addEventListener('click', (e) => {
            const swatch = e.target.closest('.color-swatch');
            if (swatch) {
                const color = swatch.dataset.color;
                selectColor(color, swatch);
            }
        });

        colorPicker.addEventListener('input', (e) => {
            selectColor(e.target.value, null);
        });

        // --- 4. .OBJ LOADING AND PROCESSING LOGIC ---

        /**
         * Parses the text of an .OBJ file
         * @param {string} objText The text content of the .obj file
         * @returns {object} An object with { vertices: [], triangles: [] }
         */
        function parseOBJ(objText) {
            const vertices = [];
            const triangles = [];
            const lines = objText.split('\n');

            for (const line of lines) {
                const parts = line.trim().split(/\s+/);
                const type = parts[0];

                if (type === 'v') {
                    // Vertex line: v x y z
                    const x = parseFloat(parts[1]) * OBJ_SCALE_X;
                    const y = parseFloat(parts[2]) * OBJ_SCALE_Y;
                    const z = parseFloat(parts[3]) * OBJ_SCALE_Z;
                    vertices.push({ x, y, z });

                } else if (type === 'f') {
                    // Face line: f v1/vt1/vn1 v2/vt2/vn2 v3/vt3/vn3
                    // We assume triangles
                    const faceVertices = [];
                    for (let i = 1; i < parts.length; i++) {
                        const v_parts = parts[i].split('/');
                        // OBJ index is 1-based, convert to 0-based
                        faceVertices.push(parseInt(v_parts[0]) - 1);
                    }
                    
                    if (faceVertices.length === 3) {
                         triangles.push({ v1: faceVertices[0], v2: faceVertices[1], v3: faceVertices[2] });
                    } 
                    // Optional: Handle Quads (4-vertex faces) by triangulating them
                    else if (faceVertices.length === 4) {
                        triangles.push({ v1: faceVertices[0], v2: faceVertices[1], v3: faceVertices[2] });
                        triangles.push({ v1: faceVertices[0], v2: faceVertices[2], v3: faceVertices[3] });
                    }
                }
            }
            
            console.log(`OBJ model parsed: ${vertices.length} vertices, ${triangles.length} triangles`);
            return { vertices, triangles };
        }

        /**
         * Loads the .obj model from the server
         */
        async function loadCustomModel() {
            try {
                // 5. OBJ path updated
                // IMPORTANT: The file must be at 'assets/pixel.obj'
                const objPath = 'assets/pixel.obj';
                const currentScriptUrl = new URL(import.meta.url);
                const absoluteObjUrl = new URL(objPath, currentScriptUrl).href;

                const response = await fetch(absoluteObjUrl);
                if (!response.ok) {
                    throw new Error(`Error loading '${objPath}': ${response.statusText}. Please ensure 'assets/pixel.obj' exists and is accessible.`);
                }
                const objText = await response.text();
                customGeometry = parseOBJ(objText);
                
                // Enable the download button
                downloadBtn.disabled = false;
                downloadBtn.textContent = 'Download .3MF';

            } catch (error) {
                console.error(error);
                alert(`Fatal Error: Could not load the 3D model. ${error.message}\n\nTo test locally, you need to run a local web server (e.g., 'python -m http.server' in the project folder).`);
                downloadBtn.textContent = 'Error loading model';
            }
        }


        // --- 5. .3MF GENERATION LOGIC ---

        async function generateAndDownload3MF() {
            
            // Check if the model is loaded
            if (!customGeometry) {
                alert("The custom 3D model has not loaded yet. Please wait a moment.");
                return;
            }

            console.log("Generating .3MF file with custom model...");
            const zip = new JSZip();

            const relsXML = `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
    <Relationship Target="/3D/3dmodel.model" Id="rel-1" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel" />
</Relationships>`;
            zip.folder("_rels").file(".rels", relsXML);

            const uniqueColors = [...new Set(gridData.filter(c => c !== null))];
            
            let baseMaterialsXML = `<basematerials id="1">`; 
            uniqueColors.forEach((color, index) => {
                const sRGBColor = color.substring(1); 
                baseMaterialsXML += `\n    <base name="Color ${index}" displaycolor="#${sRGBColor}" />`;
            });
            baseMaterialsXML += `\n</basematerials>`;

            // --- NEW: Re-architected 3MF Generation (Single Mesh, Robust Item-level Color) ---

            let resourcesXML = `\n    ${baseMaterialsXML}`;

            // 1. Get the geometry strings ONCE
            let verticesXML = `<vertices>`;
            customGeometry.vertices.forEach(v => {
                verticesXML += `\n        <vertex x="${v.x}" y="${v.y}" z="${v.z}" />`;
            });
            verticesXML += `\n    </vertices>`;

            let trianglesXML = `<triangles>`;
            customGeometry.triangles.forEach(t => {
                trianglesXML += `\n        <triangle v1="${t.v1}" v2="${t.v2}" v3="${t.v3}" />`;
            });
            trianglesXML += `\n    </triangles>`;

            // 2. Define ONE object (ID=2) that contains the mesh.
            // CRITICAL: We REMOVE pid="1" from here. The object is JUST geometry.
            // The <item> will define the color. This fixes slicers that
            // ignore the <item> color if the <object> has a pid.
            resourcesXML += `
    <object id="2" type="model">
        <mesh>
            ${verticesXML}
            ${trianglesXML}
        </mesh>
    </object>`;

            // Wrap everything in the <resources> tag
            const finalResourcesXML = `<resources>${resourcesXML}\n</resources>`;
            
            // 3. Build the scene. Each <item> specifies its own color index (pindex)
            let buildItemsXML = "";
            const objectCenterOffset = OBJECT_DIM_MM / 2; // Assume the model is centered at 0,0

            gridData.forEach((color, index) => {
                if (color !== null) {
                    const x = (index % GRID_SIZE) * TOTAL_CELL_DIM_MM + objectCenterOffset;
                    const y = (GRID_SIZE - 1 - Math.floor(index / GRID_SIZE)) * TOTAL_CELL_DIM_MM + objectCenterOffset; 
                
                const transform = `1 0 0 0 1 0 0 0 1 ${x} ${y} 0`;
                
                // Find the color index
                const colorIndex = uniqueColors.indexOf(color);
                
                // This is the most robust way that slicers understand:
                // objectid="2" -> Use the single mesh
                // pid="1" -> Use the main material group
                // pindex="${colorIndex}" -> Use *this specific color* from the group
                buildItemsXML += `\n    <item objectid="2" pid="1" pindex="${colorIndex}" transform="${transform}" />`;
            }
        });
        
        const buildXML = `<build>${buildItemsXML}\n</build>`;

            const modelXML = `<?xml version="1.0" encoding="UTF-8"?>
<model unit="millimeter" xml:lang="en-US" xmlns="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel">
    ${finalResourcesXML}
    ${buildXML}
</model>`;

            zip.folder("3D").file("3dmodel.model", modelXML);

            try {
                const blob = await zip.generateAsync({ type: "blob" });
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = "pixelmyqube_custom.3mf";
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                console.log(".3MF file generated and downloaded!");

            } catch (error) {
                console.error("Error generating the .3mf file:", error);
                alert("An error occurred while generating the .3mf file. Check the console for more details.");
            }
        }


        // --- 6. APP INITIALIZATION ---
        
        clearBtn.addEventListener('click', clearGrid);
        downloadBtn.addEventListener('click', generateAndDownload3MF);

        createGrid();
        updateStats();
        selectColor('null', document.querySelector('.color-swatch[data-color="null"]'));
        
        // Start loading the .OBJ model
        loadCustomModel();

    </script>
</body>
</html>
